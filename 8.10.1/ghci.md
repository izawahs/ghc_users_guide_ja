# 4. GHCiを使う

GHCi[^1]はGHCの対話環境で、Haskellの式を対話的に評価してプログラムは解釈可能になります。もしも[Hugs](http://www.haskell.org/hugs/)に慣れているならば、GHCiにも確実に慣れるでしょう。しかし、GHCiは対話的なコンパイル済みコードのロードをサポートしており、GHCの提供する言語拡張と同じようなもの全てをサポートしています。GHCiはまた対話的デバッガーも包括しています([GHCiデバッガ―](./ghci.md#45-GHCiデバッガ)を参照)。

[^1]: 「i」は「対話的」という意味です。
[^2]: 今のところ、`foreign export`を除きます。

## 4.1. GHCiへの導入

GHCiセッションの例を始めましょう。`ghci`コマンドでGHCiを立ち上げられます:

```ghci
$ ghci
GHCi, version 8.y.z: https://www.haskell.org/ghc/  :? for help
Prelude>
```

プロンプトが表示された後に、GHCiがPreludeと標準ライブラリをロードするのに少し時間がかかる場合があります。バナーの通り、`:?`とタイプして利用可能なコマンドの一覧を表示して、それらのそれぞれの説明を見られます。これらのコマンドのほとんどについては今後順を追って説明します、そして全てのコマンドの完全なドキュメンテーションは[GHCiコマンド](./ghci.md#47-GHCiコマンド)に存在します。

Haskellの式はプロンプトでタイプできます:

```ghci
Prelude> 1+2
3
Prelude> let x = 42 in x / 9
4.666666666666667
Prelude>
```

GHCiは全ての行を評価可能な式として解釈します。式は複数行に分割できません―エンターを押した瞬間に、GHCiは評価を試みます。

Haskellでは、`let`式は`in`に続きます。ですが、GHCiでは、式は`IO`モナド内のものとしても解釈できるため、`in`を伴わない`let`束縛は上記の例のように、空行として表せます。

GHC8.0.1から、値や関数と名前の束縛には`let`が必要なくなりました:

```ghci
Prelude> x = 42
Prelude> x
42
Prelude>
```

## 4.2. ソースファイルのロード

`Main.hs`に次のようなHaskellソースコードがあるとします:

```haskell
main = print (fac 20)

fac 0 = 1
fac n = n * fac (n-1)
```

好きな場所に`Main.hs`を保存できます、しかしどこかカレントディレクトリ以外の場所に保存した場合は[^3]現在のディレクトリをGHCiから変える必要があります:

```ghci
Prelude> :cd dir
```

\<dir\>が`Main.hs`を保存したディレクトリ(またはフォルダ)だとします。

HaskellのソースファイルをGHCiにロードするには、[**:load**](./ghci.md#load)コマンドを使います:

```ghci
Prelude> :load Main
Compiling Main             ( Main.hs, interpreted )
Ok, modules loaded: Main.
*Main>
```

GHCiは`Main`モジュールをロードして、プロンプトが`*Main>`になったらプロンプトにタイプされた式の現在の文脈が`Main`モジュールをロードしたことを意味します(`*`が何を意味するのかはすぐに[プロンプトでスコープにあるのは?](./ghci.md#445-プロンプトでスコープにあるのは)で説明します)。なので今`Main.hs`の関数を含んだ式をタイプできます:

```ghci
*Main> fac 17
355687428096000
```

複数のモジュールのプログラムのロードは簡単です; 一番上のモジュールの名前を[**:load**](./ghci.md#load)コマンドに与えるだけです(ヒント: [**:load**](./ghci.md#load)は`:l`に短縮できます)。一番上のモジュールは通常`Main`になりますが、そうなる必要はありません。GHCiは必要なモジュールを検出し、直接的または間接的に、依存関係順にロードします。

[^3]: もしもGHCiをコマンドラインから立ち上げたのであれば、GHCiのカレントディレクトリはシェルを立ち上げた時のカレントディレクトリと同じになります。WindowsでスタートメニューからGHCiを立ち上げたのであれば、おそらくカレントディレクトリは``C:\Documents and Settings\user name`のようになります。

##### `-fshow-loaded-modules`

デフォルト: オフ

導入されたバージョン: 8.2.2

ほとんどの場合GHCiは[**:load**](./ghci.md#load)コマンドでロードした後のモジュールの数を表示するだけです。このフラグを付けると、GHCiはロードしたモジュールの名前も表示します。これはGHC8.2.1以前ではデフォルトの動作であり一部のｎユーザーには役に立つかもしれません。

### 4.2.1. モジュール vs. ファイル名

質問: GHCはどのようにモジュール\<M\>を含んだファイル名を探すのですか? 回答: `M.hs`か`M.lhs`を探します。ほとんどのモジュールで、モジュール名はファイル名と一致していなければならないからです。もしそうでなければ、GHCiはそれを探せないでしょう。

この一般的なルールにはある例外があります: [**:load**](./ghci.md#load)でプログラムをロードするときに、`ghci`を呼び出した際に特定するか、モジュール名よりもファイル名を与えられます。もしそれが存在したらロードすれば、探しているものが含まれているかもしれません。もしいくつかの`Main`モジュールが同じディレクトリに存在していて全ての`Main.hs`を呼べないならば特に有用です。

ソースファイルを探すための検索パスは[**-i**](./separate-compilation.md#i)オプションでGHCiのコマンドラインで特定できます、このように:

```ghci
ghci -idir1:...:dirn
```

またはGHCIで[**:set**](./ghci.md#set)コマンドを使ってできます([GHCのコマンドライン引数をGHCiで設定する](./ghci.md#482-ghcのコマンドライン引数をghciで設定する)を参照)[^4]。

GHCiが依存関係に従ってロードするモジュールを見つける方法の1つの結果は、全てのモジュールはソースファイルを持たなければならないということです。この規則の例外はモジュールがパッケージ由来のものであるときのみで、`IO`や`Complex`のような標準ライブラリと`Prelude`などです。もしもモジュールをロードしようとしてGHCiがソースファイルを見つけられなければ、モジュールのオブジェクトとインターフェースファイルがそこにあったとしても、エラーメッセージを受け取ることになるでしょう。

[^4]: GHCiで[**--make**](./using.md#make)モード、[**-i**](./separate_compilation.md#i)はソースファイルの検索パスを特定するために使われることに注意してください、ですが標準のバッチコンパイルモードでは[**-i**](./separate_compilation.md#i)オプションはインターフェースファイルの検索パスを特定するのに使われます、[検索パス](./separate_compilation.md#683-検索パス)を参照して下さい。


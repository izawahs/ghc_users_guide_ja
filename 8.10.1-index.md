# GHCユーザーズガイドへようこそ

目次:

1. [Glasgow Haskell Compiler ライセンス](./8.10.1/license.md)

2. [GHCへの導入](./8.10.1/intro.md)

   2.1. [GHCの入手](./8.10.1/intro.md#21-ghcの入手)

   2.2. [メタ情報: ウェブサイト、メーリングリスト、他](./8.10.1/intro.md#22-メタ情報-ウェブサイト、メーリングリスト、他)

   2.3. [GHCのバグの報告](./8.10.1/intro.md#23-ghcのバグの報告)

   2.4. [GHCのバージョンの番付け方法](./8.10.1/intro.md#24-ghcのバージョンの番付け方法)

3. [バージョン8.10.1のリリースノート](./8.10.1/8.10.1-notes.md)

   3.1. ハイライト

   3.2. 詳細な情報

   ​	3.2.1. 言語機能

   ​	3.2.2. コンパイラ

   ​	3.2.3. GHC API

   ​	3.2.4. GHCi

   ​	3.2.5. ランタイムシステム

   ​	3.2.6. テンプレートHaskell

   ​	3.2.7. `ghc-prim`ライブラリ

   ​	3.2.8. `ghc`ライブラリ

   ​	3.2.9. `base`ライブラリ

   ​	3.2.10. ビルドシステム

   3.3. 含まれるライブラリ

4. [GHCiを使う](./8.10.1/ghci.md#4-ghciを使う)

   4.1. [GHCiへの導入](./8.10.1/ghci.md#41-ghciへの導入)

   4.2. [ソースファイルのロード](./8.10.1/ghci.md#42-ソースファイルのロード)

   ​	4.2.1. [モジュール vs. ファイル名](./8.10.1/ghci.md#421-モジュール-vs-ファイル名)

   ​	4.2.2. 変更を加えてリコンパイルする

   4.3. コンパイル済みのコードのロード

   4.4. プロンプトでの対話形式の評価

   ​	4.4.1. プロンプトでのI/Oアクション

   ​	4.4.2. プロンプトで`do`記法を使う

   ​	4.4.3. 複数行での入力

   ​	4.4.4. 型、クラスなどの宣言

   ​	4.4.5. プロンプトでスコープにあるのは?

   ​		4.4.5.1. スコープ内への`:load`の影響

   ​		4.4.5.2. `import`によるスコープ内の操作

   ​		4.4.5.3. `:module`コマンドによるスコープ内の操作

   ​		4.4.5.4. 修飾付きの名前

   ​	4.4.6. `:main`コマンドと`:run`コマンド

   ​	4.4.7. `it`変数

   ​	4.4.8. GHCiでの型の初期化

   ​		4.4.8.1. 対話形式でのクラス

   ​		4.4.8.2. デフォルト宣言での拡張規則

   ​	4.4.9. カスタムの対話形式の出力関数を使う

   ​	4.4.10. GHCiのスタックトレース

   4.5. GHCiデバッガ

   ​	4.5.1. ブレークポイントと変数の調査

   ​		4.5.1.1. ブレークポイントの設定

   ​		4.5.1.2. ブレークポイントの管理

   ​	4.5.2. シングルステップの実行

   ​	4.5.3. ネストしたブレークポイント

   ​	4.5.4. `_result`変数

   ​	4.5.5. トレースと履歴

   ​	4.5.6. 例外のデバッグ

   ​	4.5.7. 例: 関数の調査

   ​	4.5.8. 制約

   4.6. GHCiの呼び出し

   ​	4.6.1. パッケージ

   ​	4.6.2. 外部のライブラリ

   4.7. GHCiコマンド

   4.8. `:set`と`:seti`コマンド

   ​	4.8.1. GHCiのオプション

   ​	4.8.2. GHCのコマンドライン引数をGHCiで設定する

   ​	4.8.3. 対話形式の評価のみでのオプションの設定

   4.9. `.ghci`と`haskeline`ファイル

   ​	4.9.1. `.ghci`ファイル

   ​	4.9.2. `.haskeline`ファイル

   4.10. GHCi内でのオブジェクトコードへのコンパイル

   4.11. 個々のプロセスでのインタープリタの実行

   4.12. 別のホストでのインタープリタの実行

   4.13. FAQと諸注意

5. runghcを使う

   5.1. 使い方

   5.2. runghcフラグ

   5.3. GHCフラグ

6. GHCを使う

   6.1. GHCを使う

   ​	6.1.1 開始する: プログラムのコンパイル

   ​	6.1.2 オプションの概要

   ​		6.1.2.1. コマンドライン引数

   ​		6.1.2.2. ソースファイル内でのコマンドラインオプション

   ​		6.1.2.3. GHCiでのオプションの設定

   ​	6.1.3. DynamicとModeオプション

   ​	6.1.4. 意味を持つファイル接尾辞

   ​	6.1.5. 操作のモード

   ​		6.1.5.1 `ghc --make`を使う

   ​		6.1.5.2 式評価モード

   ​		6.1.5.3 バッチコンパイラモード

   ​	6.1.6 冗長なオプション

   ​	6.1.7. プラットフォーム固有フラグ

   ​	6.1.8. その他の雑多なフラグ

   ​		6.1.8.1. その他の環境変数

   6.2. 警告と健全性チェック

   6.3. 最適化 (コードの改善)

   ​	6.3.1. `-O*`: 最適化フラグの便利な「パッケージ」

   ​	6.3.2. `-f*`: プラットフォーム依存のフラグ

   6.4. コンカレントHaskellを使う

   6.5. SMP並行処理を使う

   ​	6.6. SMP並行処理のコンパイル時オプション

   ​	6.7. SMP並行処理のRTSオプション

   ​	6.8. SMP並行処理を使う上でのヒント

   6.6. フラグリファレンス

   ​	6.6.1 冗長なオプション

   ​	6.6.2. 操作の代替モード

   ​	6.6.3. 実行の段階

   ​	6.6.4. 出力のリダイレクト

   ​	6.6.5. 中間ファイルの保持

   ​	6.6.6. テンポラリファイル

   ​	6.6.7. インポートを見つける

   ​	6.6.8. インターフェースファイルのオプション

   ​	6.6.9. リコンパイルチェック

   ​	6.6.10. 対話モードのオプション

   ​	6.6.11. パッケージ

   ​	6.6.12. 言語オプション

   ​	6.6.13. 警告

   ​	6.6.14. 最適化レベル

   ​	6.6.15. 特有の最適化

   ​	6.6.16. プロファイリングのオプション

   ​	6.6.17. プログラムカバレッジのオプション

   ​	6.6.18. Cプリプロセッサのオプション

   ​	6.6.19. コード生成のオプション

   ​	6.6.20. リンクのオプション

   ​	6.6.21. プラグインのオプション

   ​	6.6.22. フェーズの置き換え

   ​	6.6.23. 特定のフェーズへのオプションの強制

   ​	6.6.24. プラットフォーム特有のオプション

   ​	6.6.25. コンパイラのデバッグオプション

   ​	6.6.26. 雑多なコンパイラオプション

   6.7. コンパイル済みプログラムの実行

   ​	6.7.1. RTSオプションの設定

   ​		6.7.1.1. コマンドラインでのRTSオプションの設定

   ​		6.7.1.2. コンパイル時のRTSオプションの設定

   ​		6.7.1.3. `GHCRTS`環境変数によるRTSオプションの設定

   ​		6.7.1.4. RTSの振る舞いを変えるための「フック」

   ​	6.7.2. 雑多なRTSオプション

   ​	6.7.3. ガベージコレクタをコントロールするためのRTSオプション

   ​	6.7.4. ランタイム統計を発行するためのRTSオプション

   ​	6.7.5. 並行と並列のためのRTSオプション

   ​	6.7.6. プロファイリングのためのRTSオプション

   ​	6.7.7. トレース

   ​	6.7.8. ハッカー、デバッガ、物好きのためのRTSオプション

   ​	6.7.9. RTSについての情報を得る

   6.8. ファイル名と分割コンパイル
   
   ​	6.8.1. Haskellソースファイル
   
   ​	6.8.2. 出力ファイル
   
   ​	6.8.3. 検索パス
   
   ​	6.8.4. コンパイルの出力のリダイレクト
   
   ​	6.8.5. 中間ファイルの保持
   
   ​	6.8.6. テンポラリファイルのリダイレクト
   
   ​	6.8.7. インターフェースファイルに関連するその他のオプション
   
   ​	6.8.8. 拡張のインターフェースファイルに関連するオプション
   
   ​	6.8.9. リコンパイルチェッカー
   
   ​	6.8.10. どのように相互参照しているモジュールをコンパイルするか
   
   ​	6.8.11. モジュール注釈
   
   ​	6.8.12. `make`を使う
   
   ​	6.8.13. 依存関係の生成
   
   ​	6.8.14. 廃止されたモジュールとインスタンス宣言
   
   6.9. パッケージ
   
   ​	6.9.1. パッケージを使う
   
   ​	6.9.2. `main`パッケージ
   
   ​	6.9.3. Haskell言語においてのパッケージの重要性
   
   ​	6.9.4. モジュールのリネームと分割
   
   ​	6.9.5. パッケージデータベース
   
   ​		6.9.5.1. `GHC_PACKAGE_PATH`環境変数
   
   ​		6.9.5.2. パッケージ環境
   
   ​	6.9.6. インストール済みのID、依存関係、破損したパッケージ
   
   ​	6.9.7. パッケージ管理 (`ghc-pkg`コマンド)
   
   ​	6.9.8. Haskellソースからパッケージをビルドする
   
   ​	6.9.9. `InstalledPackageInfo`: パッケージの仕様書
   
   6.10. GHCバックエンド
   
   ​	6.10.1. ネイティブコードの生成器(`-fasm`)
   
   ​	6.10.2. LLVMコードの生成器(`-fllvm`)
   
   ​	6.10.3. Cコードの生成器(`-fvia-C`)
   
   ​	6.10.4.  正式に登録されていないコンパイル方法
   
   6.11. 特定のフェーズに関連するオプション
   
   ​	6.11.1. 1つかそれ以上のフェーズのプログラムの置き換え
   
   ​	6.11.2. 特定のフェーズへのオプションの強制
   
   ​	6.11.3. Cプリプロセッサに影響するオプション
   
   ​		6.11.3.1. 標準CPPマクロ
   
   ​		6.11.3.2. CPPと文字列ギャップ
   
   ​	6.11.4. Haskellプリプロセッサに影響するオプション
   
   ​	6.11.5. コード生成に影響するオプション
   
   ​	6.11.6. リンクに影響するオプション
   
   6.12. 共有ライブラリを使う
   
   ​	6.12.1. 共有ライブラリを使ったプログラムのビルド
   
   ​	6.12.2. Haskellパッケージの共有ライブラリ
   
   ​	6.12.3. C APIの提供する共有ライブラリ
   
   ​	6.12.4. ランタイムで共有ライブラリを見つける
   
   ​		6.12.4.1. Unix
   
   ​		6.12.4.2. Mac OS X
   
   6.13. コンパイラのデバッグ
   
   ​	6.13.1. コンパイラの中間構造体を捨てる
   
   ​		6.13.1.1. フロントエンド
   
   ​		6.13.1.2. 型チェックとリネーム
   
   ​		6.13.1.3. コア表現と単純化
   
   ​		6.13.1.4. STG表現
   
   ​		6.13.1.5. C-\\-表現
   
   ​		6.13.1.6. LLVMコードの生成器
   
   ​		6.13.1.7. ネイティブコードの生成器
   
   ​		6.13.1.8. 雑多なバックエンドのダンプ
   
   ​	6.13.2. ダンプのフォーマット
   
   ​	6.13.3. 不要な情報を抑制する
   
   ​	6.13.4. 堅牢性のチェック
   
   ​	6.13.5. 決定論のチェック
   
   ​	6.13.6. その他
   
7.  プロファイリング

   7.1. コストセンターとコストセンターのスタック

   ​	7.1.1. 手でコストセンターの挿入する

   ​	7.1.2. コストに帰するための規則

   7.2. プロファイリングのためのコンパイラオプション

   7.3. 時間とアロケーションのプロファイリング

   ​	7.3.1. JSONプロファイルフォーマット

   7.4. メモリ使用量のプロファイル

   ​	7.4.1. ヒープをプロファイルするためのRTSオプション

   ​	7.4.2. 保持器のプロファイル

   ​		7.4.2.1. 保持器のプロファイルを使う上でのヒント

   ​	7.4.3. 伝記体のプロファイル

   ​	7.4.4. 実際のメモリの在り処

   7.5. `hp2ps` - ヒーププロファイルのPostScriptへの描画

   ​	7.5.1. `hp`ファイルの操作

   ​	7.5.2. あなたのプロファイルの範囲にズームする

   ​	7.5.3. 実行中のプログラムのヒーププロファイルを見る

   ​	7.5.4. リアルタイムでヒーププロファイルを見る

   7.6. 並列及び並行処理のプログラムのプロファイル

   7.7. コードカバレッジを観測する

   ​	7.7.1. 単純な例: 往復運動

   ​	7.7.2. カバレッジのためのコードを計測するオプション

   ​	7.7.3. hpcツールキット

   ​		7.7.3.1. hpc report

   ​		7.7.3.2. hpc markup

   ​		7.7.3.3. hpc sum

   ​		7.7.3.4. hpc combine

   ​		7.7.3.5. hpc map

   ​		7.7.3.6. hpc overlayとhpc draft

   ​	7.7.4. Haskellプログラムのカバレッジの注意と欠点

   7.8. 「味気ない」プロファイルを使う(実装者向け)

8. 忠告: すぐに、素早く、小さく、節約

   8.1. すぐに: さらに素早くプログラムを作る

   8.2. 素早く: 素早く動作するプログラムを作る

   8.3. 小さく: さらに小さいプログラムを作る

   8.4. 節約: さらにメモリ消費の少ないプログラムを作る

9. GHCの言語機能

   9.1. 言語オプション

   9.2. アンボックス化型と基本の演算

   ​	9.2.1. アンボックス化型

   ​	9.2.2. アンボックス化型カインド

   ​	9.2.3. アンボックス化タプル

   ​	9.2.4. アンボックス化直和型

   ​	9.2.5. 持ち上げられていないnewtype

   9.3. 構文の拡張

   ​	9.3.1. Unicode構文

   ​	9.3.2. マジックハッシュ

   ​	9.3.3. 負数リテラル

   ​	9.3.4. 小数の整数リテラル

   ​	9.3.5. 2進数リテラル

   ​	9.3.6. 16進数の小数リテラル

   ​	9.3.7. 数値の下線

   ​	9.3.8. パターンガード

   ​	9.3.9. ViewPatterns

   ​	9.3.10. n+kパターン

   ​	9.3.11. 再帰的なdo構文

   ​		9.3.11.1. ネストした束縛のグループ

   ​		9.3.11.2. `mdo`構文

   ​	9.3.12. アプリカティブdo構文

   ​		9.3.12.1. 正格パターン

   ​		9.3.12.2. 注意すべきこと

   ​	9.3.13. 並行リスト内包

   ​	9.3.14. 一般化された(SQLライクな)リスト内包

   ​	9.3.15. モナド値のリスト内包

   ​	9.3.16. モナディックな失敗の新しい脱糖メカニズム

   ​	9.3.17. 再束縛可能な構文と暗黙のPreludeインポート

   ​		9.3.17.1 `RebindableSyntax`に影響されないもの

   ​	9.3.18. 後置演算子

   ​		9.3.19. タプルセクション

   ​		9.3.20. ラムダケース

   ​		9.3.21. 空のケースの代替

   ​		9.3.22. 複数のif式

   ​		9.3.23. ローカルな中置演算子の定義

   ​		9.3.24. インポートとエクスポートの拡張

   ​			9.3.24.1. インポートされたモジュールのうちエクスポートしないものを隠す

   ​			9.3.24.2. パッケージ修飾されたインポート

   ​			9.3.24.3. 安全なインポート

   ​			9.3.24.4. インポート/エクスポートの名前空間の明示

   ​			9.3.24.5. 後置で修飾を行う

   ​		9.3.25. さらに自由な関数の引数のための構文

   ​			9.3.25.1. 文法への変更

   ​		9.3.26. 奪われた構文の概略

   ​	9.4. データ型と型シノニムへの拡張

   ​		9.4.1. コンストラクタを持たないデータ型

   ​		9.4.2. データ型の文脈	

   ​		9.4.3. 中置型コンストラクタ、クラス、型変数

   ​		9.4.4. 型演算子	

   ​		9.4.5. 自由化された型シノニム

   ​		9.4.6. 存在的な修飾された値コンストラクタ

   ​			9.4.6.1. なぜ存在的なのか?

   ​			9.4.6.2. 存在量化と型クラス

   ​			9.4.6.3. レコードコンストラクタ

   ​			9.4.6.4. 限定

   ​		9.4.7. 注釈を明示したデータ型の定義

   ​		9.4.8. 一般化された代数的データ型 (GADTs)

   ​	9.5. レコードシステムの為の拡張

   ​		9.5.1. 伝統的なレコード構文

   ​		9.5.2. レコードフィールドの曖昧さ排除

   ​		9.5.3. レコードフィールドの重複

   ​			9.5.3.1. セレクタ関数

   ​			9.5.3.2. レコードの更新

   ​			9.5.3.3. レコードフィールドのインポートとエクスポート

   ​		9.5.4. Record puns

   ​		9.5.5. レコードのワイルドカード

   ​		9.5.6. レコードフィールドセレクタの多相性

   ​			9.5.6.1. HasField制約の解除

   ​			9.5.6.2. 仮想レコードフィールド

   ​	9.6. 「導出」メカニズムへの拡張

   ​		9.6.1. 空のデータ型のインスタンス導出

   ​		9.6.2. deriving節での文脈の推論

   ​		9.6.3. 独立したderiving宣言

   ​		9.6.4. 外部の節のインスタンスの導出

   ​			9.6.4.1. `Functor`インスタンスの導出

   ​			9.6.4.2. `Foldable`インスタンスの導出

   ​			9.6.4.3. `Traversable`インスタンスの導出

   ​			9.6.4.4. `Data`インスタンスの導出

   ​			9.6.4.5. `Typeable`インスタンスの導出

   ​			9.6.4.6. `Lift`インスタンスの導出

   ​		9.6.5. 一般化されたnewtypeのインスタンス導出

   ​			9.6.5.1. deriving節の一般化

   ​			9.6.5.2. さらに明確な仕様書

   ​			9.6.5.3. 関連する型族

   ​		9.6.6. その他の任意のクラスの導出

   ​		9.6.7. 導出戦略

   ​			9.6.8. デフォルトの導出戦略

   ​		9.6.8. 導出によって

   ​	9.7. パターンシノニム

   ​		9.7.1. レコードパターンシノニム

   ​		9.7.2. パターンシノニムの構文とスコープ

   ​		9.7.3. パターンシノニムのインポートとエクスポート

   ​		9.7.4. パターンシノニムの型付け

   ​		9.7.5. パターンシノニムのマッチ

   ​	9.8. クラスとインスタンス宣言

   ​		9.8.1. クラス宣言

   ​			9.8.1.1. マルチパラメータの型クラス

   ​			9.8.1.2. クラス宣言のスーパークラス

   ​			9.8.1.3. 制約付きのクラスメソッド型

   ​			9.8.1.4. デフォルトのメソッド注釈

   ​			9.8.1.5. 引数のない型クラス

   ​		9.8.2. 関数型の依存関係

   ​			9.8.2.1. 関数型の依存関係のルール

   ​			9.8.2.2. 関数型の依存関係の背景

   ​		9.8.3. インスタンス宣言

   ​			9.8.3.1. インスタンスの解析

   ​			9.8.3.2. インスタンス文頭の緩い制約

   ​			9.8.3.3. インスタンス文脈の緩い制約

   ​			9.8.3.4. インスタンス末尾の制約

   ​			9.8.3.5. 非決定的なインスタンス

   ​			9.8.3.6. インスタンスの重ね合わせ

   ​			9.8.3.7. インスタンス注釈: インスタンス宣言での型注釈

   ​		9.8.4. オーバーロードされた文字列リテラル

   ​		9.8.5. オーバーロードされたラベル

   ​		9.8.6. オーバーロードされたリスト

   ​			9.8.6.1. `IsList`クラス

   ​			9.8.6.2. 再束縛可能な構文

   ​			9.8.6.3. 初期化

   ​			9.8.6.4. 未来の思索

   ​		9.8.7. 非決定的な(あるいは再帰的な)スーパークラス

   ​	9.9. 型族

   ​		9.9.1. データ族

   ​			9.9.1.1. データ族宣言

   ​			9.9.1.2. データインスタンス宣言

   ​			9.9.1.3. データインスタンスの重ね合わせ

   ​		9.9.2. シノニム族

   ​			9.9.2.1. 型族宣言

   ​			9.9.2.2. 型インスタンス宣言

   ​			9.9.2.3. 閉じた型族

   ​			9.9.2.4. 型族の例

   ​			9.9.2.5. 型族の等式の互換性と離れていること

   ​			9.9.2.6. 型シノニムインスタンスの決定性

   ​		9.9.3. データと型族のインスタンスのLHSでのワイルドカード

   ​		9.9.4. 関連したデータと型族

   ​			9.9.4.1. 関連するインスタンス

   ​			9.9.4.2. 関連する型シノニムのデフォルト

   ​			9.9.4.3. クラスパラメータの引数

   ​			9.9.4.4. インスタンスの文脈と関連する型とデータインスタンス

   ​		9.9.5. インポートとエクスポート

   ​			9.9.5.1. 例

   ​			9.9.5.2. インスタンス

   ​		9.9.6. 型族とインスタンス宣言

   ​		9.9.7. 単射の型族

   ​			9.9.7.1. 単射性注釈の構文

   ​			9.9.7.2. 型族の式に対する単射性注釈の適用

   ​	9.10. データ型の昇格

   ​		9.10.1. 動機付け

   ​		9.10.2. 概略

   ​		9.10.3. 型とコンストラクタ間の識別

   ​		9.10.4. 昇格されたリストとタプル型

   ​		9.10.5. 存在量的な値コンストラクタの昇格

   ​	9.11. カインド多相

   ​		9.11.1. カインド多相の概要

   ​		9.11.2. Type-in-Typeの概要

   ​		9.11.3. カインドのインターフェースの原理

   ​		9.11.4. 型/クラス宣言での変数の階級の推論

   ​		9.11.5. 完全なユーザー提供の種注釈と多相再帰

   ​		9.11.6. 独立した種注釈と多相再帰

   ​		9.11.7. 独立した種注釈と宣言ヘッダ

   ​		9.11.8. 閉じた型族での種推論

   ​		9.11.9. クラスインスタンス宣言での種推論

   ​		9.11.10. 型注釈での種推論

   ​		9.11.11. 明示的なカインドの量化

   ​		9.11.12. 型シノニムでの暗黙の量化と型族インスタンス

   ​		9.11.13. カインド添え字付きのGADTs

   ​		9.11.14. 高階カインド

   ​		9.11.15. カインドの制約

   ​		9.11.16. `Type`カインド

   ​		9.11.17. データ型宣言での依存関係の推論

   ​		9.11.18. ユーザーの書いた`forall`での依存関係の推論

   ​		9.11.19. `PolyKinds`を使わないカインドの初期化

   ​		9.11.20. カインド多相の様子のプリティプリント

   ​	9.12. 軽率な多相性

   ​		9.12.1. 軽率な多相的変数または引数の排除

   ​		9.12.2. 軽率な多相的ボトム

   ​		9.12.3. 軽率な多相的型の出力

   ​	9.13. 型レベルリテラル

   ​		9.13.1. 型レベルリテラルのランタイム値

   ​		9.13.2. 型レベル自然数の計算

   ​	9.14. 等値性制約、強制、種制約

   ​		9.14.1. 等値性制約

   ​		9.14.2. 非同次な等値性

   ​		9.14.3. 持ち上げられていない非同次の等値性

   ​		9.14.4. `Coercible`制約

   ​		9.14.5. `Constraint`カインド

   ​	9.15. 制約の量化

   ​		9.15.1. 動機付け

   ​		9.15.2. 構文の変更

   ​		9.15.3. 型付けの変更

   ​		9.15.4. スーパークラス

   ​		9.15.5. 重ね合わせ

   ​		9.15.6. インスタンス探索

   ​		9.15.7. 末尾

   ​		9.15.8. 一貫性

   ​	9.16. 型注釈の拡張

   ​		9.16.1. 全体量化の明示 (forall)

   ​		9.16.2. 型注釈の制約

   ​		9.16.3. 曖昧な型と曖昧さチェック

   ​		9.16.4. 明示的カインドの量化

   ​	9.17. レキシカルスコープの型変数

   ​		9.17.1. 概要

   ​		9.17.2. 型注釈宣言

   ​		9.17.3. 型注釈の表現

   ​		9.17.4. 型注釈パターン

   ​		9.18.5. クラスとインスタンス宣言

   ​	9.18. 束縛と一般化

   ​		9.18.1. 恐るべき単射性制約を切る

   ​		9.18.2. Letの一般化

   ​	9.19. 目に見える型適用

   ​		9.19.1. 推論された vs. 規定された型変数

   ​		9.19.2. 指定された変数の階級付け

   ​	9.20. 暗黙のパラメータ

   ​		9.20.1. 暗黙のパラメータの型制約

   ​		9.20.2. 暗黙のパラメータの束縛

   ​		9.20.3. 暗黙のパラメータと多相再帰

   ​		9.20.4. 暗黙のパラメータと単射性

   ​	9.21. 任意のランク多相

   ​		9.21.1. 例

   ​		9.21.2. 型推論

   ​		9.21.3. 暗黙の量化

   ​	9.22. 非断定的な多相性

   ​	9.23. 型付きホール

   ​		9.23.1. 合法なホールの適用

   ​			9.23.1.1. ホールの適用の精緻さ

   ​			9.23.1.2. 合法なホールの適用の分類

   ​	9.24. 部分的な型注釈

   ​		9.24.1. 構文

   　		9.24.1.1. 型ワイルドカード

   ​			9.24.1.2. 名前付きワイルドカード

   ​			9.24.1.3. 拡張付き制約ワイルドカード

   ​		9.24.2. どこに表れるのか?

   ​	9.25. カスタムコンパイル時エラー

   ​	9.26. ランタイム型エラーの遅延

   ​		9.26.1. 型エラーの遅延を有効にする

   ​		9.26.2. GHCiでの遅延された型エラー

   ​		9.26.3. 遅延された型エラーの限界

   ​	9.27. Template Haskell

   ​		9.27.1. 構文

   ​		9.27.2. Template Haskellを使う

   ​		9.27.3. Template Haskellの生成されたコードを見る

   ​		9.27.4. Template Haskellの動作例

   ​		9.27.5. プロファイルとともにTemplate Haskellを使う

   ​		9.27.6. Template Haskellに似た引用

   ​	9.28. Arrow記法

   ​		9.28.1. コマンドのdo記法

   ​		9.28.2. 条件コマンド

   ​		9.28.3. オリジナルの制御構造を定義する

   ​		9.28.4. 論文との違い

   ​		9.28.5. 可搬性

   ​	9.29. Bang patternsとStrict Haskell

   ​		9.29.1 Bang patterns

   ​		9.29.2. デフォルト正格なデータ型

   ​		9.29.3. デフォルト正格なパターン束縛

   ​		9.29.4. モジュール性

   ​		9.29.5. Bang patternsの動的意味論

   ​	9.30. アサーション

   ​	9.31. 静的ポインタ

   ​		9.31.1. 静的ポインタを使う

   ​		9.31.2. 静的ポインタの静的意味論

   ​	9.32. プラグマ

   ​		9.32.1. `LANGUAGE`プラグマ

   ​		9.32.2. `OPTIONS_GHC`プラグマ

   ​		9.32.3. `INCLUDE`プラグマ

   ​		9.32.4. `WARNING`と`DEPRECATE`プラグマ

   ​		8.32.5. `MINIMAL`プラグマ

   ​		9.32.6. `INLINE`と`NOINLINE`プラグマ

   ​			9.32.6.1. `INLINE`プラグマ

   ​			9.32.6.2. `INLINABLE`プラグマ

   ​			9.32.6.3. `NOINLINE`プラグマ

   ​			9.32.6.4. `CONLIKE`プラグマ

   ​			9.32.6.5. フェーズコントロール

   ​		9.32.7. `LINE`プラグマ

   ​		9.32.8. `COLUMN`プラグマ

   ​		9.32.9. `RULES`プラグマ

   ​		9.32.10. `SPECIALIZE`プラグマ

   ​			9.32.10.1. `SPECIALIZE INLINE`

   ​			9.32.10.2. インポートされた関数への`SPECIALIZE`

   ​		9.32.11. `SPECIALIZE`インスタンスプラグマ

   ​		9.32.12. `UNPACK`プラグマ

   ​		9.32.13. `NOUNPACK`プラグマ

   ​		9.32.14. `SOURCE`プラグマ

   ​		9.32.15. `COMPLETE`プラグマ

   ​		9.32.16. `OVERLAPPING`、`OVERLAPPABLE`、`OVERLAPS`、`INCOHERENT`プラグマ

   ​	9.33. 書き換え規則

   ​		9.33.1. 構文

   ​		9.33.2. 意味論

   ​		9.33.3. どのようにルールが`INLINE`/`NOINLINE`プラグマと相互に作用するか

   ​		9.33.4. どのようにルールが`CONLIKE`プラグマと相互に作用するか

   ​		9.33.5. どのようにルールがクラスメソッドと相互に作用するか

   ​		9.33.6. リストの融合

   ​		9.33.7. 特殊化

   ​		9.33.8. 書き換え規則内の動作をコントロールする

   ​	9.34. 特殊な組み込み関数

   ​	9.35. 一般的なクラス

   ​	9.36. 一般的なプログラミング

   ​		9.36.1. 表現の導出

   ​		9.36.2. 一般的な関数を書く

   ​		9.36.3. 持ち上げられてない表現の型

   ​		9.36.4. 一般的な初期値

   ​		9.36.5. 追加の情報

   ​	9.37. ロール

   ​		9.37.1. Nominal、Representional、Phantom

   ​		9.37.3. ロール推論

   ​		9.37.2. ロールアノテーション

   ​	9.38. HasCallStack

   ​		9.38.1. 他のスタックトレースのソースとの比較

   ​	9.39. 並行及び並列Haskell

   ​		9.39.1. 並行Haskell

   ​		9.39.2. ソフトウェアトランザクショナルメモリ

   ​		9.39.3. 並列Haskell

   ​		9.39.4. 並列性の純粋なコードへの注釈

   ​	9.40. Safe Haskell

   ​		9.40.1. Safe Haskellの用法

   ​			9.40.1.1. 正格な型安全性 (良いスタイル)

   ​			9.40.1.2. 万全な体制の構築 (制限されたIOモナド)

   ​		9.40.2. Safe Language

   ​			9.40.2.1. 安全なインスタンスの重ね合わせ

   ​		9.40.3. 安全なインポート

   ​		9.40.4.  信頼とSafe Haskellモード

   ​			9.40.4.1. 信頼性チェック (`-fpackage-trust`が無効)

   ​			9.40.4.2. 信頼性チェック (`-fpackage-trust`が無効)

   ​		9.40.5. Safe Haskellの推論

   ​		9.40.6. Safe Haskellのフラグの概略

   ​		9.40.7. 安全なコンパイル

10. 外部関数インターフェース (FFI)
    10.1. GHCとFFIの章の違い

     ​	10.1.1. 安全な呼び出しの保証

    10.2. FFIチャプターのGHC拡張

       ​	10.2.1. 持ち上げられていないFFIの型

       ​	10.2.2. IOモナドのnewtypeでのラッピング

       ​	10.2.3. 外部の型での`forall`の明示

       ​	10.2.4. 組み込みのインポート

       ​	10.2.5. 中断可能な外部呼出し

       ​	10.2.6. CAPIの呼び出しの慣習

       ​	10.2.7. `hs_thread_done()`

       ​	10.2.8. 多くの安定したポインタを能率的に解放する

    10.3. GHCとともにFFIを使う

       ​	10.3.1. `foreign export`と`foreign import call "wrapper"`をGHCと使う

       ​		10.3.1.1. 自分の`main()`を使う

       ​		10.3.1.2. 外部のコードから呼び出せるHaskellライブラリを作る

       ​	10.3.2. ヘッダファイルを使う

       ​	10.3.3. メモリ割り当て

       ​	10.3.4. マルチスレッドとFFI

       ​		10.3.4.1. 外部インポートとマルチスレッド

       ​		10.3.4.2. HaskellスレッドとOSスレッドの関係

       ​		10.3.4.3. 外部エクスポートとマルチスレッド

       ​		10.3.4.4. `hs_exit()`を使う上で

       ​		10.3.4.5. CからHaskellスレッドを立ち上げる

       ​	10.3.5. FFIと浮動小数点

       ​	10.3.6. 固定長バイト列

11. GHCをライブラリとして使い拡張する

    11.1. ソース注釈

       ​	11.1.1. 値の注釈

       ​	11.1.2. 型の注釈

       ​	11.1.3. モジュールの注釈

    11.2. GHCをライブラリとして使う

    11.3. コンパイラプラグイン

       ​	11.3.1. コンパイラプラグインを使う

       ​	11.3.2. コンパイラプラグインを書く

       ​	11.3.3. 詳細なコアプラグイン

       ​		11.3.3.1. 束縛を操作する

       ​		11.3.3.2. 注釈を使う

       ​	11.3.4. 型チェッカープラグイン

       ​		11.3.4.1. プラグインによる制約の解除

       ​	11.3.5. ソースプラグイン

       ​		11.3.5.1. パース後の表現

       ​		11.3.5.2. 型チェック後の表現

       ​		11.3.5.3. 評価後のコード

       ​		11.3.5.4. インターフェースファイル

       ​		11.3.5.5. ソースプラグインの例

       ​	11.3.6. ホール適用のプラグイン

       ​		11.3.6.1. 状態付きホール適用プラグイン

       ​		11.3.6.2. ホール適用プラグインの例

       ​	11.3.7. リコンパイルのコントロール

       ​	11.3.8. フロントエンドのプラグイン

       ​	11.3.9. DynFlagsプラグイン

12. 誤っている時に何をすべきか

    12.1. コンパイラが「誤ったことをしている」時

    12.2. プログラムが「誤ったことをしている」時

13. コンパイル済みプログラムのデバッグ

    13.1. チュートリアル

    13.2. Haskellコードからのスタックトレースのリクエスト

    13.3. `SIGQUIT`付きスタックトレースのリクエスト

    13.4. 実装者のメモ: DWARFアノテーション

       ​	13.4.1. 情報をデバッグする

       ​		13.4.1.1. `DW_TAG_ghc_src_note`

    13.5. 追加の読み物

14. その他のHaskellユーティリティ

    14.1. 「HaskellのためのYacc」: `happy`

    14.2. CコードのためのHaskellインターフェースを書く: `hsc2hs`

       ​	14.2.1. コマンドラインの構文

       ​	14.2.2. 入力の構文

       ​	14.2.3. カスタム構造体

       ​	14.2.4. クロスコンパイル

15. Win32システムでGHCを実行する

    15.1. WindowsプラットフォームでGHCを開始する
	
    15.2. WindowsでGHCiを実行する

    15.3. ターミナルとの相互運用

    15.4. ライブラリの動作の違い

    15.5. Windows下でのファイルパス

    15.6. CygwinでGHC (とGHCでコンパイルされた実行可能ファイル)を使う

       ​	15.6.1. バックエンド

       ​	15.6.2. 問題点

       ​	15.6.3. するべきこと

    15.7. Win32 DLLをビルドして使う

       ​	15.7.1. DLLの作成

       ​	15.7.2. 他の言語から呼び出せるDLLを作る

       ​		15.7.3. VBAから使う

       ​		15.7.4. C++から使う

16. 既知のバグと不適切なもの

    16.1. Haskellの標準 vs. Glasgow Haskell: 言語の非準拠

       ​	16.1.1. Haskell 2010のHaskell 98からの違い

       ​		16.1.1.1. 字句要素

       ​		16.1.1.2. 文脈自由文法

       ​		16.1.1.3. 式とパターン

       ​		16.1.1.4. 宣言と束縛

       ​		16.1.1.5. 型チェックと再帰的な束縛のグループ

       ​		16.1.1.6. -main-isの付いたデフォルトのモジュールヘッダ

       ​		16.1.1.7. モジュールシステムとインターフェースファイル

       ​		16.1.1.8. 数値、基本の型、組み込みクラス

       ​		16.1.1.9. `Prelude`のサポートについて

       ​		16.1.1.10. 外部関数インターフェース

       ​		16.1.1.11. 演算子セクション

       ​	16.1.2. Haskell 98とHaskell 2010の未定義の動作のGHCでの解釈

    16.2. 既知のバグと不適切なもの

       ​	16.2.1. GHCのバグ

       ​	16.2.2. GHCi(対話形式のGHC)のバグ

17. イベントログのエンコーディング

    17.1. ヒーププロファイラのイベントログの出力

       ​	17.1.1. メタデータとイベントの型

       ​		17.1.1.1. サンプルストリームの開始

       ​		17.1.1.2. コストセンターの定義

       ​	17.1.2. イベントタイプの例

       ​		17.1.2.1. コストセンターの破損

       ​		17.1.2.2. 文字列の破損

    17.2. 時間プロファイラのイベントログの出力

       ​	17.2.1. プロファイルのイベントの開始

       ​	17.2.2. サンプルイベントのチェック

18. GHCユーザーズガイドへの配慮とフィード

    18.1. 基礎

       ​	18.1.1. 見出し

       ​	18.1.2. コードの整形

       ​		18.1.2.1. Haskell

       ​		18.1.2.2. 他の言語

       ​	18.1.3. リンク

       ​		18.1.3.1. ユーザーズガイド内

       ​		18.1.3.2. GHCの資料

       ​		18.1.3.3. 外部の資料

       ​		18.1.3.4. コアライブラリのHaddockドキュメント

       ​		18.1.3.5. 数学

       ​	18.1.4. 目次

    18.2. 出典

    18.3. 助言

    18.4. コマンドラインオプションの記録とGHCiのコマンド

       ​	18.4.1. コマンドラインオプション

       ​	18.4.2. GHCiコマンド

    18.5. スタイル規則

    18.6. ReSTリファレンスマニュアル

## インデックスとテーブル

- インデックス
- 検索ページ


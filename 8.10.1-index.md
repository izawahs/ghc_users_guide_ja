# GHCユーザーズガイドへようこそ

目次:

1. [Glasgow Haskell Compiler ライセンス](./8.10.1/license.md)

2. [GHCへの導入](./8.10.1/intro.md)

   2.1. GHCの入手

   2.2. メタ情報: ウェブサイト、メーリングリスト、他

   2.3. GHCのバグの報告

   2.4. GHCのバージョンの番付け方法

3. バージョン8.10.1のリリースノート

   3.1. ハイライト

   3.2. 詳細な情報

   ​	3.2.1. 言語機能

   ​	3.2.2. コンパイラ

   ​	3.2.3. GHC API

   ​	3.2.4. GHCi

   ​	3.2.5. ランタイムシステム

   ​	3.2.6. テンプレートHaskell

   ​	3.2.7. `ghc-prim`ライブラリ

   ​	3.2.8. `ghc`ライブラリ

   ​	3.2.9. `base`ライブラリ

   ​	3.2.10. ビルドシステム

   3.3. 含まれるライブラリ

4. GHCiを使う

   4.1. GHCiへの導入

   4.2. ソースファイルのロード

   ​	4.2.1. モジュール vs. ファイル名

   ​	4.2.2. 変更を加えてリコンパイルする

   4.3. コンパイル済みのコードのロード

   4.4. プロンプトでの対話形式の評価

   ​	4.4.1. プロンプトでのI/Oアクション

   ​	4.4.2. プロンプトで`do`記法を使う

   ​	4.4.3. 複数行での入力

   ​	4.4.4. 型、クラスなどの宣言

   ​	4.4.5. プロンプトでスコープにあるのは?

   ​		4.4.5.1. スコープ内への`:load`の影響

   ​		4.4.5.2. `import`によるスコープ内の操作

   ​		4.4.5.3. `:module`コマンドによるスコープ内の操作

   ​		4.4.5.4. 修飾付きの名前

   ​	4.4.6. `:main`コマンドと`:run`コマンド

   ​	4.4.7. `it`変数

   ​	4.4.8. GHCiでの型の初期化

   ​		4.4.8.1. 対話形式でのクラス

   ​		4.4.8.2. デフォルト宣言での拡張規則

   ​	4.4.9. カスタムの対話形式の出力関数を使う

   ​	4.4.10. GHCiのスタックトレース

   4.5. GHCiデバッガ

   ​	4.5.1. ブレークポイントと変数の調査

   ​		4.5.1.1. ブレークポイントの設定

   ​		4.5.1.2. ブレークポイントの管理

   ​	4.5.2. シングルステップの実行

   ​	4.5.3. ネストしたブレークポイント

   ​	4.5.4. `_result`変数

   ​	4.5.5. トレースと履歴

   ​	4.5.6. 例外のデバッグ

   ​	4.5.7. 例: 関数の調査

   ​	4.5.8. 制約

   4.6. GHCiの呼び出し

   ​	4.6.1. パッケージ

   ​	4.6.2. 外部のライブラリ

   4.7. GHCiコマンド

   4.8. `:set`と`:seti`コマンド

   ​	4.8.1. GHCiのオプション

   ​	4.8.2. GHCのコマンドライン引数をGHCiで設定する

   ​	4.8.3. 対話形式の評価のみでのオプションの設定

   4.9. `.ghci`と`haskeline`ファイル

   ​	4.9.1. `.ghci`ファイル

   ​	4.9.2. `.haskeline`ファイル

   4.10. GHCi内でのオブジェクトコードへのコンパイル

   4.11. 個々のプロセスでのインタープリタの実行

   4.12. 別のホストでのインタープリタの実行

   4.13. FAQと諸注意

5. runghcを使う

   5.1. 使い方

   5.2. runghcフラグ

   5.3. GHCフラグ

6. GHCを使う

   6.1. GHCを使う

   ​	6.1.1 開始する: プログラムのコンパイル

   ​	6.1.2 オプションの概要

   ​		6.1.2.1. コマンドライン引数

   ​		6.1.2.2. ソースファイル内でのコマンドラインオプション

   ​		6.1.2.3. GHCiでのオプションの設定

   ​	6.1.3. DynamicとModeオプション

   ​	6.1.4. 意味を持つファイル接尾辞

   ​	6.1.5. 操作のモード

   ​		6.1.5.1 `ghc --make`を使う

   ​		6.1.5.2 式評価モード

   ​		6.1.5.3 バッチコンパイラモード

   ​	6.1.6 冗長なオプション

   ​	6.1.7. プラットフォーム固有フラグ

   ​	6.1.8. その他の雑多なフラグ

   ​		6.1.8.1. その他の環境変数

   6.2. 警告と健全性チェック

   6.3. 最適化 (コードの改善)

   ​	6.3.1. `-O*`: 最適化フラグの便利な「パッケージ」

   ​	6.3.2. `-f*`: プラットフォーム依存のフラグ

   6.4. コンカレントHaskellを使う

   6.5. SMP並行処理を使う

   ​	6.6. SMP並行処理のコンパイル時オプション

   ​	6.7. SMP並行処理のRTSオプション

   ​	6.8. SMP並行処理を使う上でのヒント

   6.6. フラグリファレンス

   ​	6.6.1 冗長なオプション

   ​	6.6.2. 操作の代替モード

   ​	6.6.3. 実行の段階

   ​	6.6.4. 出力のリダイレクト

   ​	6.6.5. 中間ファイルの保持

   ​	6.6.6. テンポラリファイル

   ​	6.6.7. インポートを見つける

   ​	6.6.8. インターフェースファイルのオプション

   ​	6.6.9. リコンパイルチェック

   ​	6.6.10. 対話モードのオプション

   ​	6.6.11. パッケージ

   ​	6.6.12. 言語オプション

   ​	6.6.13. 警告

   ​	6.6.14. 最適化レベル

   ​	6.6.15. 特有の最適化

   ​	6.6.16. プロファイリングのオプション

   ​	6.6.17. プログラムカバレッジのオプション

   ​	6.6.18. Cプリプロセッサのオプション

   ​	6.6.19. コード生成のオプション

   ​	6.6.20. リンクのオプション

   ​	6.6.21. プラグインのオプション

   ​	6.6.22. フェーズの置き換え

   ​	6.6.23. 特定のフェーズへのオプションの強制

   ​	6.6.24. プラットフォーム特有のオプション

   ​	6.6.25. コンパイラのデバッグオプション

   ​	6.6.26. 雑多なコンパイラオプション

   6.7. コンパイル済みプログラムの実行

   ​	6.7.1. RTSオプションの設定

   ​		6.7.1.1. コマンドラインでのRTSオプションの設定

   ​		6.7.1.2. コンパイル時のRTSオプションの設定

   ​		6.7.1.3. `GHCRTS`環境変数によるRTSオプションの設定

   ​		6.7.1.4. RTSの振る舞いを変えるための「フック」

   ​	6.7.2. 雑多なRTSオプション

   ​	6.7.3. ガベージコレクタをコントロールするためのRTSオプション

   ​	6.7.4. ランタイム統計を発行するためのRTSオプション

   ​	6.7.5. 並行と並列のためのRTSオプション

   ​	6.7.6. プロファイリングのためのRTSオプション

   ​	6.7.7. トレース

   ​	6.7.8. ハッカー、デバッガ、物好きのためのRTSオプション

   ​	6.7.9. RTSについての情報を得る

   6.8. ファイル名と分割コンパイル
   
   ​	6.8.1. Haskellソースファイル
   
   ​	6.8.2. 出力ファイル
   
   ​	6.8.3. 検索パス
   
   ​	6.8.4. コンパイルの出力のリダイレクト
   
   ​	6.8.5. 中間ファイルの保持
   
   ​	6.8.6. テンポラリファイルのリダイレクト
   
   ​	6.8.7. インターフェイスファイルに関連するその他のオプション
   
   ​	6.8.8. 拡張のインターフェイスファイルに関連するオプション
   
   ​	6.8.9. リコンパイルチェッカー
   
   ​	6.8.10. どのように相互参照しているモジュールをコンパイルするか
   
   ​	6.8.11. モジュール注釈
   
   ​	6.8.12. `make`を使う
   
   ​	6.8.13. 依存関係の生成
   
   ​	6.8.14. 廃止されたモジュールとインスタンス宣言
   
   6.9. パッケージ
   
   ​	6.9.1. パッケージを使う
   
   ​	6.9.2. `main`パッケージ
   
   ​	6.9.3. Haskell言語においてのパッケージの重要性
   
   ​	6.9.4. モジュールのリネームと分割
   
   ​	6.9.5. パッケージデータベース
   
   ​		6.9.5.1. `GHC_PACKAGE_PATH`環境変数
   
   ​		6.9.5.2. パッケージ環境
   
   ​	6.9.6. インストール済みのID、依存関係、破損したパッケージ
   
   ​	6.9.7. パッケージ管理 (`ghc-pkg`コマンド)
   
   ​	6.9.8. Haskellソースからパッケージをビルドする
   
   ​	6.9.9. `InstalledPackageInfo`: パッケージの仕様書
   
   6.10. GHCバックエンド
   
   ​	6.10.1. ネイティブコードの生成器(`-fasm`)
   
   ​	6.10.2. LLVMコードの生成器(`-fllvm`)
   
   ​	6.10.3. Cコードの生成器(`-fvia-C`)
   
   ​	6.10.4.  正式に登録されていないコンパイル方法
   
   6.11. 特定のフェーズに関連するオプション
   
   ​	6.11.1. 1つかそれ以上のフェーズのプログラムの置き換え
   
   ​	6.11.2. 特定のフェーズへのオプションの強制
   
   ​	6.11.3. Cプリプロセッサに影響するオプション
   
   ​		6.11.3.1. 標準CPPマクロ
   
   ​		6.11.3.2. CPPと文字列ギャップ
   
   ​	6.11.4. Haskellプリプロセッサに影響するオプション
   
   ​	6.11.5. コード生成に影響するオプション
   
   ​	6.11.6. リンクに影響するオプション
   
   6.12. 共有ライブラリを使う
   
   ​	6.12.1. 共有ライブラリを使ったプログラムのビルド
   
   ​	6.12.2. Haskellパッケージの共有ライブラリ
   
   ​	6.12.3. C APIの提供する共有ライブラリ
   
   ​	6.12.4. ランタイムで共有ライブラリを見つける
   
   ​		6.12.4.1. Unix
   
   ​		6.12.4.2. Mac OS X
   
   6.13. コンパイラのデバッグ
   
   ​	6.13.1. コンパイラの中間構造体を捨てる
   
   ​		6.13.1.1. フロントエンド
   
   ​		6.13.1.2. 型チェックとリネーム
   
   ​		6.13.1.3. コア表現と単純化
   
   ​		6.13.1.4. STG表現
   
   ​		6.13.1.5. C-\\-表現
   
   ​		6.13.1.6. LLVMコードの生成器
   
   ​		6.13.1.7. ネイティブコードの生成器
   
   ​		6.13.1.8. 雑多なバックエンドのダンプ
   
   ​	6.13.2. ダンプのフォーマット
   
   ​	6.13.3. 不要な情報を抑制する
   
   ​	6.13.4. 堅牢性のチェック
   
   ​	6.13.5. 決定論のチェック
   
   ​	6.13.6. その他
   
7.  プロファイリング

   7.1. コストセンターとコストセンターのスタック

   ​	7.1.1. 手でコストセンターの挿入する

   ​	7.1.2. コストに帰するための規則

   7.2. プロファイリングのためのコンパイラオプション

   7.3. 時間とアロケーションのプロファイリング

   ​	7.3.1. JSONプロファイルフォーマット

   7.4. メモリ使用量のプロファイル

   ​	7.4.1. ヒープをプロファイルするためのRTSオプション

   ​	7.4.2. 保持器のプロファイル

   ​		7.4.2.1. 保持器のプロファイルを使う上でのヒント

   ​	7.4.3. 伝記体のプロファイル

   ​	7.4.4. 実際のメモリの在り処

   7.5. `hp2ps` - ヒーププロファイルのPostScriptへの描画

   ​	7.5.1. `hp`ファイルの操作

   ​	7.5.2. あなたのプロファイルの範囲にズームする

   ​	7.5.3. 実行中のプログラムのヒーププロファイルを見る

   ​	7.5.4. リアルタイムでヒーププロファイルを見る

   7.6. 並列及び並行処理のプログラムのプロファイル

   7.7. コードカバレッジを観測する

   ​	7.7.1. 単純な例: 往復運動

   ​	7.7.2. カバレッジのためのコードを計測するオプション

   ​	7.7.3. hpcツールキット

   ​		7.7.3.1. hpc report

   ​		7.7.3.2. hpc markup

   ​		7.7.3.3. hpc sum

   ​		7.7.3.4. hpc combine

   ​		7.7.3.5. hpc map

   ​		7.7.3.6. hpc overlayとhpc draft

   ​	7.7.4. Haskellプログラムのカバレッジの注意と欠点

   7.8. 「味気ない」プロファイルを使う(実装者向け)

8. 忠告: すぐに、素早く、小さく、節約

   8.1. すぐに: さらに素早くプログラムを作る

   8.2. 素早く: 素早く動作するプログラムを作る

   8.3. 小さく: さらに小さいプログラムを作る

   8.4. 節約: さらにメモリ消費の少ないプログラムを作る

9. GHC言語機能

   9.1. 言語オプション

   9.2. アンボックス化型と基本の演算

   ​	9.2.1. アンボックス化型

   ​	9.2.2. アンボックス化型カインド

   ​	9.2.3. アンボックス化タプル

   ​	9.2.4. アンボックス化直和型

   ​	9.2.5. 持ち上げられていないnewtype

   9.3. 構文の拡張

   ​	9.3.1. Unicode構文

   ​	9.3.2. マジックハッシュ

   ​	9.3.3. 負数リテラル

   ​	9.3.4. 小数の整数リテラル

   ​	9.3.5. 2進数リテラル

   ​	9.3.6. 16進数の小数リテラル

   ​	9.3.7. 数値の下線

   ​	9.3.8. パターンガード

   ​	9.3.9. ViewPatterns

   ​	9.3.10. n+kパターン

   ​	9.3.11. 再帰的なdo構文

   ​		9.3.11.1. ネストした束縛のグループ

   ​		9.3.11.2. `mdo`構文

   ​	9.3.12. アプリカティブdo構文

   ​		9.3.12.1. 正格パターン

   ​		9.3.12.2. 注意すべきこと

   ​	9.3.13. 並行リスト内包

   ​	9.3.14. 一般化された(SQLライクな)リスト内包

   ​	9.3.15. モナド値のリスト内包

   ​	9.3.16. モナディックな失敗の新しい脱糖メカニズム

   ​	9.3.17. 再束縛可能な構文と暗黙のPreludeインポート

   ​		9.3.17.1 `RebindableSyntax`に影響されないもの

   ​	9.3.18. 後置演算子

   ​		9.3.19. タプルセクション

   ​		9.3.20. ラムダケース

   ​		9.3.21. 空のケースの代替

   ​		9.3.22. 複数のif式

   ​		9.3.23. ローカルな中置演算子の定義

   ​		9.3.24. インポートとエクスポートの拡張

   ​			9.3.24.1. インポートされたモジュールのうちエクスポートしないものを隠す

   ​			9.3.24.2. パッケージ修飾されたインポート

   ​			9.3.24.3. 安全なインポート

   ​			9.3.24.4. インポート/エクスポートの名前空間の明示

   ​			9.3.24.5. 後置で修飾を行う

   ​		9.3.25. さらに自由な関数の引数のための構文

   ​			9.3.25.1. 文法への変更

   ​		9.3.26. 奪われた構文の概略

   ​	9.4. データ型と型シノニムへの拡張

   ​		9.4.1. コンストラクタを持たないデータ型

   ​		9.4.2. データ型の文脈	

   ​		9.4.3. 中置型コンストラクタ、クラス、型変数

   ​		9.4.4. 型演算子	

   ​		9.4.5. 自由化された型シノニム

   ​		9.4.6. 存在的な修飾された値コンストラクタ

   ​			9.4.6.1. なぜ存在的なのか?

   ​			9.4.6.2. 存在量化と型クラス

   ​			9.4.6.3. レコードコンストラクタ

   ​			9.4.6.4. 限定

   ​		9.4.7. 注釈を明示したデータ型の定義

   ​		9.4.8. 一般化された代数的データ型 (GADTs)

   ​	9.5. レコードシステムの為の拡張

   ​		9.5.1. 























